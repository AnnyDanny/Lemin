написать функция для эррора


About graph!!!!

Ну, когда мы впервые узнали о поиске по ширине (BFS) и поиске по глубине (DFS) в этой серии, они оба были в контексте обхода дерева. Хотя деревья являются подмножеством графиков, они, безусловно, очень разные структуры. Таким образом, процесс обхода графика отличается от обхода дерева, что на самом деле требует пересмотра этих двух методов поиска в контексте графиков, а не деревьев.
Итак, сначала первое: что мы имеем в виду, когда говорим «пересечение»? Начнем с определения.
|
|
|
>>>>

1. in depth-first search, we can determine whether two nodes x and y have a path between them by looking at the children of the starting node and secursively determining if a path exists

1. при поиске по глубине мы можем определить, имеют ли два узла x и y путь между ними, просматривая дочерние элементы исходного узла и последовательно определяя, существует ли путь

Акт поиска или прохождения через структуру данных графа довольно прост: это просто означает, что мы, вероятно, посещаем каждую вершину (и по прокси, каждому отдельному ребру) на графике. В самом ее ядре единственная разница между перемещением графа по ширине или по глубине - это порядок, в котором мы находим вершины в графе. Другими словами, порядок, в котором посещаются вершины графа, на самом деле заключается в том, как мы можем классифицировать различные алгоритмы обхода графа.
Поскольку мы уже знакомы с DFS и BFS в контексте деревьев, давайте быстро сравним их на высоком уровне, прежде чем погрузиться в BFS в деталях.


Теперь, если мы сравним DFS с тем, что мы знаем о BFS, или в первом поиске, мы начнем видеть, что, хотя эти два алгоритма могут показаться похожими, они в основном выполняют две очень разные вещи. Поразительное различие между двумя алгоритмами заключается в том, как они подходят к проблеме ходьбы или прохождения по графику. Как мы обнаружили на прошлой неделе, алгоритм BFS будет проходить через график на один уровень за раз, посещая все дочерние объекты любой заданной вершины - соседние узлы, которые равноудалены в том, как далеко от «родительского» узла на графике.

3. depth-first
traverses deep into a structure by visiting children nodes before visiting sibling/neithbor nodes. uses a stack data structure
3. в глубину
обход глубоко в структуру, посетив дочерние узлы перед посещением узлов / сестер. использует структуру данных стека

breadth-first
traverses broad int a structure by visiting sibling/neighbor nodes before children nodes. uses a data structure

в ширину
пересекает широкую внутреннюю структуру, посещая узлы / сестры / дочерние узлы перед дочерними узлами. использует структуру данных

Подобно тому, как он реализован в структурах древовидных данных, поиск по глубине проходит вглубь структур графа путем посещения дочерних узлов перед посещением родственных или соседних узлов. При обходе дерева и графика алгоритм DFS использует структуру данных стека. Для сравнения, алгоритм поиска по ширине в широком масштабе пересекает структуру, посещая соседние узлы-сестры перед посещением дочерних узлов. При обходе дерева и графика алгоритм BFS реализует структуру данных очереди.

поиске по ширине (BFS) и поиске по глубине (DFS) !!!!!!!!!!!!!!!!!!!!!!!!!!


Стек - структура данных с доступом к элементам по принципу LIFO (Last In First Out - Последний пришел - первый вышел). Данные добавляются в начало (конец, кому как удобно), оттуда же и извлекаются. Для реализации данной структуры достаточно иметь лишь две функции и указатель на верхушку:

push(item); //добавляет данные в стек
pop(); //извлекает последний элемент
Очередь - структура данных с доступом к элементам по принципу FIFO (First In First Out - Первый пришел - Первый вышел). Данные добавляются в конец, а извлекаются из начала. Для быстрого добавления и извлечения данных понадобится два указателя, один на начало, очереди, второй на ее конец. Для работы с очередью используются функции:

enqueue(item); //добавляет новый элемент в очередь
dequeue(); //извлекает элемент из очереди


Однако поиск по глубине занимает другой подход: он перемещается по одному пути в графе, пока он не сможет пройти дальше, проверяя один дочерний узел за раз.
Первый алгоритм имеет один путь, следуя этому пути вниз по структуре графика до его окончания. Однако метод поиска по ширине, однако, оценивает все возможные пути от данного узла одинаково, проверяя все потенциальные вершины из одного узла вместе и сравнивая их одновременно.









2. while breath-first search will traverse through a graph one level of children at time, depth-first search will traverse down a single path6 one child node at a time7 

2. в то время как поиск вперёд сначала будет проходить через график на один уровень детей во времени, поиск по глубине будет проходить по одному пути 6 один дочерний узел за раз 7



3 - количество муравьев
##start
0 (номер комнаты) 1 0 (координаты комнаты) - с какой комнаты начинают
##end 
1 5 0 - на какой комнате заканчивают
2 9 0 
3 13 0

0-2 -> связи комнат 
2-3
3-1

L1 (первый муравей, изначально находился в нулевой комнате(всегда муравьи сначала находятся в нулевой комнате)) -2 (теперь во второй)
L1-3 L2-2
L1-1 L2-3 L3-2
L2-1 L3-3
L3-1

проверить что находится в строке до пробела, там должно находится название комнаты - оно может быть какое угодно и его нужно записывать в char*

проверить какое число находится сразу после пробела - там будет первая координата и также проверить что находится после первой координаты и одного пробела - это будет вторая координата

после двух хешей должен быть старт или енд, если они есть тогда можно записывать в строку старт и энед с хешами и проверять после них следующие координаты, которые будут стартовыми или ендовыми

так же можно проверять и количесто мурав. - листать когда есть числа

потом это все записывать в листы

чар записывать в чаровский элемент, а инты с помощью итоа записывать в интовские элементы

первая строка - это количество муравьев, там могут быть коментарии, но там точно будет число и точно в первой строке

связи ищутся по такому же методу, как и координаты, только в данном случае идет поиск тире и числа до тире(это первое название комнаты) и после тире - это второе название комнаты


в цикле проверяю каждю строку. Если это старт или енд , или в строке есть левые символы, тогда просто пишу еррор.
если эти условия прошли и это не комментарий - просто достаю число и брейкаю цикл, если не хочу дальше что-то читать и проверять в цикле.
главное, чтобы пропустить комментарий и проверять, что это не старт и не енд. И проверить, что в строке только цифры.


!!!!! делает сегфолт, если в стартовых координатах отправляю два пробела(в любом порядке и в любом месте(главное, что когда их только два - выводит сегфолт))! на все остальные не валидные случаи с пробелами - выводит эррр


нужно сделать полностью отдельные функции для ендовских координат в отдельном файле, потому так они не будут записываться




может быть старт и енд в любом месте необязательно друг за другом
поэтому данная валидация не универсальна. на пример: сначала у меня будет енд, а потом старт (с валидными данными и координатами), работает? - да. 
пример другой: сначала енд потом старт и один из них не с валидными. - вроде работает, то есть прерывает считывание и печатает еррор.
пример третий: сначала у меня просто разные координат, потом старт и енд. - работает! 
то есть нужно сделать валидацию отдельно для координат и спрашивать, чтобы это был не старт и не энд.


номера который определяются координатами
количество комнат
ссылки которые определяются именами
название номеров не всегда будут номерами и правильными, но комнаты никогда не будут начинать с символа л или решетки
координаты комнат всегда будут целыми числами



запись связей!!!
1. связи можно записывать в тот же лист, что и все остальные данные!
в каждой связи содержиться имена двух комнат, имена комнат записаны, как чары.
поэтому проверку нужно делать на символы.
то есть получается что один элемент листа ссылается на второй элемент, которые в связях находится.
при записи связей, можно сразу идти по списку с комнатами и ссылаться на другую комнату